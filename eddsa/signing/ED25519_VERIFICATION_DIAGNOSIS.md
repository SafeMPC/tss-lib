# Ed25519 Verification Failure Diagnostic Guide

## Problem Description

Signatures generated by tss-lib cannot pass standard `crypto/ed25519.Verify` verification.

## Key Findings

### RFC 8032 Ed25519 Format Notes

**Important**: According to RFC 8032, Ed25519 uses **LITTLE-ENDIAN** encoding, not big-endian!

- **Public Key Format**: 32 bytes, little-endian encoding of Y coordinate, with the highest bit (bit 255) indicating X's sign
- **Signature Format**: 64 bytes, R || S, each is 32 bytes of little-endian encoding

### tss-lib Output Format

tss-lib's internal functions already output little-endian format:
- `bigIntToEncodedBytes()`: Returns little-endian format (reverses byte order)
- `ecPointToEncodedBytes()`: Returns little-endian format public key

**Conclusion**: tss-lib output should already be in standard Ed25519 format (little-endian)!

## Diagnostic Steps

### Step 1: Check Direct Verification

```go
import (
    "crypto/ed25519"
    "github.com/SafeMPC/tss-lib/eddsa/signing"
)

// Get tss-lib signature and public key
sigData := <-endCh
tssPubKey := signing.ecPointToEncodedBytes(keyData.EDDSAPub.X(), keyData.EDDSAPub.Y())

// Direct verification (no conversion)
valid := ed25519.Verify(ed25519.PublicKey(tssPubKey[:]), message, sigData.Signature)
```

**If direct verification succeeds**:
- ✅ tss-lib output is already in standard Ed25519 format
- ✅ Conversion functions not needed
- ✅ Can be used directly on blockchain

**If direct verification fails**: Proceed to Step 2

### Step 2: Check Public Key Format

Standard Ed25519 public key encoding:
- 32 bytes of Y coordinate (little-endian)
- Highest bit (bit 7 of byte 31) indicates X's sign

Check tss-lib public key:
```go
// tss-lib public key
tssPubKey := ecPointToEncodedBytes(x, y)

// Check format
fmt.Printf("Public key: %x\n", tssPubKey[:])
fmt.Printf("MSB (bit 255): %d\n", (tssPubKey[31] >> 7) & 1)
```

### Step 3: Check Signature Format

Standard Ed25519 signature:
- R: 32 bytes (little-endian)
- S: 32 bytes (little-endian)
- Signature = R || S (64 bytes)

Check tss-lib signature:
```go
fmt.Printf("Signature R: %x\n", sigData.Signature[:32])
fmt.Printf("Signature S: %x\n", sigData.Signature[32:])
fmt.Printf("R (big.Int): %s\n", new(big.Int).SetBytes(sigData.R).String())
fmt.Printf("S (big.Int): %s\n", new(big.Int).SetBytes(sigData.S).String())
```

### Step 4: Algorithm-Level Difference Check

If formats are all correct but verification still fails, it may be an algorithm-level difference:

1. **Challenge Calculation**: Check if `h = SHA-512(R || A || M)` calculation is correct
2. **Scalar Operations**: Check if S calculation complies with Ed25519 specification
3. **Point Encoding**: Check if R point encoding complies with Ed25519 specification

## Possible Causes

### 1. Public Key Encoding Issue

**Symptoms**: Public key format doesn't comply with standard Ed25519

**Check Method**:
```go
// Compare with standard Ed25519 public key format
stdPubKey, _, _ := ed25519.GenerateKey(rand.Reader)
tssPubKey := ecPointToEncodedBytes(x, y)

// Check format differences
fmt.Printf("Standard pubkey format: %x\n", stdPubKey)
fmt.Printf("tss-lib pubkey format: %x\n", tssPubKey[:])
```

### 2. Signature Format Issue

**Symptoms**: Signature format doesn't comply with standard Ed25519

**Check Method**:
```go
// Compare with standard Ed25519 signature format
stdSig := ed25519.Sign(stdPrivKey, message)
fmt.Printf("Standard signature: %x\n", stdSig)
fmt.Printf("tss-lib signature: %x\n", sigData.Signature)
```

### 3. Algorithm Incompatibility

**Symptoms**: Format is correct but verification fails

**Possible Causes**:
- tss-lib's EdDSA implementation differs from standard Ed25519 at the algorithm level
- Challenge calculation method differs
- Scalar operation method differs

## Solutions

### Solution A: If Direct Verification Succeeds

If tss-lib output is already in standard format:

```go
// Use directly, no conversion needed
valid := ed25519.Verify(
    ed25519.PublicKey(ecPointToEncodedBytes(x, y)[:]),
    message,
    sigData.Signature,
)
```

### Solution B: If Format Needs Adjustment

If format issues are found, encoding functions need to be fixed.

### Solution C: If Algorithm is Incompatible

If algorithm-level incompatibility exists, may need to:
1. Modify tss-lib's signature generation algorithm
2. Or, use an adapter layer for format conversion
3. Or, use other TSS libraries that support standard Ed25519

## Test Code

Use the following code for diagnosis:

```go
package main

import (
    "crypto/ed25519"
    "crypto/rand"
    "fmt"
    "math/big"
    
    "github.com/SafeMPC/tss-lib/eddsa/signing"
)

func diagnose(sigData *common.SignatureData, pubKeyX, pubKeyY *big.Int, message []byte) {
    // 1. Direct verification
    tssPubKey := signing.ecPointToEncodedBytes(pubKeyX, pubKeyY)
    valid := ed25519.Verify(ed25519.PublicKey(tssPubKey[:]), message, sigData.Signature)
    fmt.Printf("Direct verification: %v\n", valid)
    
    // 2. Use conversion functions
    standardSig, _ := signing.SignatureToStandardEd25519(sigData.Signature)
    standardPubKey := signing.PublicKeyToStandardEd25519(pubKeyX, pubKeyY)
    valid2 := ed25519.Verify(ed25519.PublicKey(standardPubKey[:]), message, standardSig)
    fmt.Printf("Converted verification: %v\n", valid2)
    
    // 3. Format comparison
    stdPubKey, stdPrivKey, _ := ed25519.GenerateKey(rand.Reader)
    stdSig := ed25519.Sign(stdPrivKey, message)
    fmt.Printf("\nStandard Ed25519 pubkey: %x\n", stdPubKey)
    fmt.Printf("tss-lib pubkey: %x\n", tssPubKey[:])
    fmt.Printf("\nStandard Ed25519 signature: %x\n", stdSig)
    fmt.Printf("tss-lib signature: %x\n", sigData.Signature)
}
```

## Next Steps

1. **Run Diagnostic Code**: Use the above code to check actual formats
2. **Compare Formats**: Compare format differences between tss-lib output and standard Ed25519
3. **Fix Issues**: Fix encoding functions or algorithms based on diagnostic results
